/* eslint-disable react-hooks/rules-of-hooks */
// From https://gist.github.com/nandorojo/052887f99bb61b54845474f324aa41cc
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { Platform } from 'react-native';
import { useNavigation } from '../router/use-navigation';
import Router from './router';
import { useRoute } from './use-route';
import { useRouter } from './use-router';
function useStable(value) {
    const ref = useRef(value);
    useEffect(() => {
        ref.current = value;
    }, [value]);
    return ref;
}
function useStableCallback(callback) {
    const callbackRef = useRef(callback);
    useEffect(() => {
        callbackRef.current = callback;
    });
    // https://github.com/facebook/react/issues/19240
    return useMemo(() => ((...args) => callbackRef.current?.(...args)), []);
}
export function createParam() {
    function useParam(...[name, maybeConfig]) {
        const { parse = (value) => value, initial, stringify = (value) => `${value}`, paramsToClearOnSetState, } = maybeConfig || {};
        const nextRouter = useRouter();
        const nativeRoute = useRoute();
        const nativeNavigation = useNavigation();
        const nativeStateFromParams = nativeRoute?.params?.[name];
        const [nativeStateFromReact, setNativeStateFromReact] = useState(() => nativeStateFromParams ?? initial);
        const setNativeStateFromParams = useCallback((value) => {
            nativeNavigation?.setParams({
                [name]: value,
            });
        }, []);
        const nativeState = nativeRoute
            ? nativeStateFromParams
            : nativeStateFromReact;
        const setNativeState = nativeRoute
            ? setNativeStateFromParams
            : setNativeStateFromReact;
        const stableStringify = useStableCallback(stringify);
        const stableParse = useStableCallback(parse);
        const stableParamsToClear = useStable(paramsToClearOnSetState);
        const initialValue = useRef(initial);
        const hasSetState = useRef(false);
        const setState = useCallback((value, options) => {
            hasSetState.current = true;
            const { pathname, query } = Router;
            const newQuery = { ...query };
            if (value != null && value !== '') {
                newQuery[name] = stableStringify(value);
            }
            else {
                delete newQuery[name];
            }
            if (stableParamsToClear.current) {
                for (const paramKey of stableParamsToClear.current) {
                    delete newQuery[paramKey];
                }
            }
            const willChangeExistingParam = query[name] && newQuery[name];
            let action = willChangeExistingParam ? Router.replace : Router.push;
            if (options?.webBehavior) {
                action = Router[options.webBehavior];
            }
            action({
                pathname,
                query: newQuery,
            }, undefined, {
                shallow: true,
            });
        }, [name, stableStringify, stableParamsToClear]);
        const webParam = nextRouter?.query?.[name];
        const state = useMemo(() => {
            let state;
            if (webParam === undefined && !hasSetState.current) {
                state = initialValue.current;
            }
            else {
                state = stableParse(webParam);
            }
            return state;
        }, [stableParse, webParam]);
        if (Platform.OS !== 'web') {
            if (!nativeRoute) {
                console.error(`[solito] useParam('${name}') called when there is no React Navigation route available. In a future version, this will throw an error. Please fix this by only calling useParam() inside of a React Navigation route. For now, Solito will fallback to using React state.`);
            }
            return [nativeState, setNativeState];
        }
        return [state, setState];
    }
    function useUpdateParams() {
        const nativeNavigation = useNavigation();
        const setNativeStateFromParams = useCallback((value) => {
            nativeNavigation?.setParams(value);
        }, []);
        const setWebState = useCallback((value, options) => {
            const { pathname, query } = Router;
            const newQuery = { ...query, ...value };
            for (const key in value) {
                if (value[key] == null || value[key] === '') {
                    delete newQuery[key];
                }
            }
            const action = options?.web?.replace ? Router.replace : Router.push;
            action({
                pathname,
                query: newQuery,
            }, undefined, {
                shallow: true,
            });
        }, []);
        return Platform.select({
            web: setWebState,
            default: setNativeStateFromParams,
        });
    }
    function useParams() {
        if (Platform.OS !== 'web') {
            const nativeRoute = useRoute();
            const nativeNavigation = useNavigation();
            return {
                params: nativeRoute?.params,
                setParams: useCallback((params) => nativeNavigation?.setParams(params), [nativeNavigation]),
            };
        }
        const nextRouter = useRouter();
        return {
            params: nextRouter?.query,
            setParams: useCallback((params, options) => {
                const { pathname, query } = Router;
                const newQuery = { ...query, ...params };
                for (const key in params) {
                    if (params[key] == null || params[key] === '') {
                        delete newQuery[key];
                    }
                }
                const action = Router[options?.webBehavior ?? 'push'];
                action({
                    pathname,
                    query: newQuery,
                }, undefined, {
                    shallow: true,
                });
            }, []),
        };
    }
    return {
        useParam,
        useUpdateParams,
        useParams,
    };
}
//# sourceMappingURL=index.js.map