declare type Config<Props extends Record<string, unknown>, Required extends boolean, ParsedType, InitialValue> = (Required extends false ? {
    parse?: (value?: string | string[]) => ParsedType;
} : {
    parse: (value?: string | string[]) => ParsedType;
}) & {
    stringify?: (value: ParsedType) => string;
    initial: InitialValue;
    paramsToClearOnSetState?: (keyof Props)[];
};
declare type Params<Props extends Record<string, unknown> = Record<string, string>, Name extends keyof Props = keyof Props, NullableUnparsedParsedType extends Props[Name] | undefined = Props[Name] | undefined, ParseFunction extends undefined | ((value?: string | string[]) => NonNullable<NullableUnparsedParsedType>) = (value?: string | string[]) => NonNullable<NullableUnparsedParsedType>, InitialValue = NullableUnparsedParsedType | undefined, ParsedType = InitialValue extends undefined ? NullableUnparsedParsedType : ParseFunction extends undefined ? NullableUnparsedParsedType : NonNullable<NullableUnparsedParsedType>> = NonNullable<ParsedType> extends string ? [name: Name, config: Config<Props, false, ParsedType, InitialValue>] | [name: Name] : [name: Name, config: Config<Props, true, ParsedType, InitialValue>];
declare type Returns<Props extends Record<string, unknown> = Record<string, string>, Name extends keyof Props = keyof Props, NullableUnparsedParsedType extends Props[Name] | undefined = Props[Name] | undefined, ParseFunction extends undefined | ((value?: string | string[]) => NonNullable<NullableUnparsedParsedType>) = (value?: string | string[]) => NonNullable<NullableUnparsedParsedType>, InitialValue = NullableUnparsedParsedType | undefined, ParsedType = InitialValue extends undefined ? NullableUnparsedParsedType : ParseFunction extends undefined ? NullableUnparsedParsedType : NonNullable<NullableUnparsedParsedType>> = readonly [
    state: ParsedType | InitialValue,
    setState: (value: ParsedType, options?: SetStateOptions) => void
];
declare type SetStateOptions = {
    /**
     * Override whether this function calls `Router.push` or `Router.replace`.
     *
     * By default, `Router.push` is called if the query parameter already exists in the URL.
     */
    webBehavior?: 'push' | 'replace';
};
export declare function createParam<Props extends Record<string, unknown> = Record<string, string>>(): {
    useParam: <Name extends keyof Props, NullableUnparsedParsedType extends Props[Name] | undefined = Props[Name] | undefined, ParseFunction extends ((value?: string | string[] | undefined) => NonNullable<NullableUnparsedParsedType>) | undefined = (value?: string | string[] | undefined) => NonNullable<NullableUnparsedParsedType>, InitialValue = NullableUnparsedParsedType | undefined, ParsedType = InitialValue extends undefined ? NullableUnparsedParsedType : ParseFunction extends undefined ? NullableUnparsedParsedType : NonNullable<NullableUnparsedParsedType>>(...[name, maybeConfig]: Params<Props, Name, NullableUnparsedParsedType, ParseFunction, InitialValue, ParsedType>) => Returns<Props, Name, NullableUnparsedParsedType, ParseFunction, InitialValue, ParsedType>;
    useUpdateParams: () => (props: Partial<Props>, options?: {
        web?: {
            replace?: boolean | undefined;
        } | undefined;
    } | undefined) => void;
    useParams: () => {
        params: Props;
        setParams: (value: Partial<Props>, options?: SetStateOptions | undefined) => void;
    };
};
export {};
